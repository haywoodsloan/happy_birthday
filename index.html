<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />

    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png" />
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png" />
    <link rel="manifest" href="/site.webmanifest" />

    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100..900;1,100..900&display=swap"
      rel="stylesheet"
    />
    <style>
      html,
      body {
        margin: 0;
        padding: 0;

        height: 100%;
        overflow: hidden;
      }

      canvas {
        position: absolute;
      }
    </style>

    <title>Happy Birthday!</title>
  </head>
  <body>
    <main>
      <canvas height="0" width="0"></canvas>
      <canvas height="0" width="0"></canvas>
    </main>

    <script type="module">
      import Color from 'https://cdn.jsdelivr.net/npm/color@5.0.0/+esm';
      import BezierEasing from 'https://cdn.jsdelivr.net/npm/bezier-easing@2.1.0/+esm';

      const easing = BezierEasing(0.25, 0.1, 0.25, 1.0);

      const urlParams = new URLSearchParams(window.location.search);
      const nameTxt = urlParams.get('name')?.toUpperCase() ?? 'FRIEND';

      const [main, cover] = document.getElementsByTagName('canvas');
      const coverCtx = cover.getContext('2d', { willReadFrequently: true });
      const mainCtx = main.getContext('2d', {
        willReadFrequently: true,
        alpha: false,
      });

      await document.fonts.load('1px Roboto');
      mainCtx.font = '1px Roboto';

      const { width: bWidth } = mainCtx.measureText('BIRTHDAY');
      const { width: nWidth } = mainCtx.measureText(`${nameTxt}!`);
      const maxWidth = Math.max(bWidth, nWidth);

      let fgColor;
      let bgColor;
      randomizeColors();
      let pixelCnt = 0;

      let patternIdx = 0;
      const patterns = [simple, scanner, dissolve, lines, spiral];

      cover.addEventListener('click', () => {
        patternIdx = (patternIdx + 1) % patterns.length;
        randomizeColors();
        patterns[patternIdx](true);
      });

      // Main render loop
      requestAnimationFrame(function loop() {
        render();
        requestAnimationFrame(loop);
      });

      function render() {
        const resized = resize();
        patterns[patternIdx](resized);
      }

      // Spiral Pattern
      const spiralDurationMs = 3000;
      const spiralStartHoldMs = 350;
      const spiralEndHoldMs = 350;
      const spiralMaxDim = 20;

      let lastSpiralLoop = Date.now();
      let curSpiralCords = [0, 0];
      let curSpiralBlock = 0;

      let spiralXBounds = [0, 0];
      let spiralYBounds = [0, 0];

      let spiralDirection = '';
      let spiralBlockCnt = 0;
      let spiralBlockSize = 0;

      function spiral(reset) {
        if (reset) {
          curSpiralCords = [0, 0];
          curSpiralBlock = 0;

          spiralDirection = 'right';
          spiralXBounds = [0, cover.width];
          spiralYBounds = [0, cover.height];

          spiralBlockSize = Math.floor(
            Math.max(cover.width / spiralMaxDim, cover.height / spiralMaxDim)
          );

          spiralBlockCnt =
            Math.floor(cover.width / spiralBlockSize) *
            Math.floor(cover.height / spiralBlockSize);

          resetForTransform();
          lastSpiralLoop = Date.now();

          return;
        }

        const now = Date.now();
        if (
          now - lastSpiralLoop >
          spiralDurationMs + spiralEndHoldMs + spiralStartHoldMs
        ) {
          curSpiralCords = [0, 0];
          curSpiralBlock = 0;

          spiralDirection = 'right';
          spiralXBounds = [0, cover.width];
          spiralYBounds = [0, cover.height];

          randomizeColors();
          resetForTransform();

          lastSpiralLoop = Date.now();
          return;
        }

        const ratio = easing(
          Math.max(now - lastSpiralLoop - spiralStartHoldMs, 0) /
            spiralDurationMs
        );

        const newBlock = Math.min(
          Math.round(ratio * spiralBlockCnt),
          spiralBlockCnt
        );

        for (; curSpiralBlock < newBlock; curSpiralBlock++) {
          switch (spiralDirection) {
            case 'right':
              if (curSpiralCords[0] + spiralBlockSize <= spiralXBounds[1]) {
                coverCtx.clearRect(
                  curSpiralCords[0],
                  curSpiralCords[1],
                  spiralBlockSize,
                  spiralBlockSize
                );

                // Catch any extras to the right
                curSpiralCords[0] += spiralBlockSize;
                if (cover.width - curSpiralCords[0] < spiralBlockSize) {
                  coverCtx.clearRect(
                    curSpiralCords[0],
                    curSpiralCords[1],
                    spiralBlockSize,
                    spiralBlockSize
                  );
                }

                break;
              } else {
                spiralDirection = 'down';
                spiralYBounds[0] += spiralBlockSize;
                curSpiralCords[1] += spiralBlockSize;
                curSpiralCords[0] -= spiralBlockSize;
              }
            case 'down':
              if (curSpiralCords[1] + spiralBlockSize <= spiralYBounds[1]) {
                coverCtx.clearRect(
                  curSpiralCords[0],
                  curSpiralCords[1],
                  spiralBlockSize,
                  spiralBlockSize
                );

                // Catch any extras to the right
                if (cover.width - (curSpiralCords[0] + spiralBlockSize) > 0) {
                  coverCtx.clearRect(
                    curSpiralCords[0] + spiralBlockSize,
                    curSpiralCords[1],
                    spiralBlockSize,
                    spiralBlockSize
                  );
                }

                // Catch any extras to the bottom-right
                curSpiralCords[1] += spiralBlockSize;
                if (cover.height - curSpiralCords[1] < spiralBlockSize) {
                  coverCtx.clearRect(
                    curSpiralCords[0],
                    curSpiralCords[1],
                    spiralBlockSize * 2,
                    spiralBlockSize * 2
                  );
                }

                break;
              } else {
                spiralDirection = 'left';
                spiralXBounds[1] -= spiralBlockSize;
                curSpiralCords[0] -= spiralBlockSize;
                curSpiralCords[1] -= spiralBlockSize;
              }
            case 'left':
              if (curSpiralCords[0] >= spiralXBounds[0]) {
                coverCtx.clearRect(
                  curSpiralCords[0],
                  curSpiralCords[1],
                  spiralBlockSize,
                  spiralBlockSize
                );

                // Catch any extras to the bottom
                if (cover.height - (curSpiralCords[1] + spiralBlockSize) > 0) {
                  coverCtx.clearRect(
                    curSpiralCords[0],
                    curSpiralCords[1] + spiralBlockSize,
                    spiralBlockSize,
                    spiralBlockSize
                  );
                }

                curSpiralCords[0] -= spiralBlockSize;
                break;
              } else {
                spiralDirection = 'up';
                spiralYBounds[1] -= spiralBlockSize;
                curSpiralCords[1] -= spiralBlockSize;
                curSpiralCords[0] += spiralBlockSize;
              }
            case 'up':
              if (curSpiralCords[1] >= spiralYBounds[0]) {
                coverCtx.clearRect(
                  curSpiralCords[0],
                  curSpiralCords[1],
                  spiralBlockSize,
                  spiralBlockSize
                );
                
                curSpiralCords[1] -= spiralBlockSize;
                break;
              } else {
                curSpiralBlock--;
                spiralDirection = 'right';
                spiralXBounds[0] += spiralBlockSize;
                curSpiralCords[0] += spiralBlockSize;
                curSpiralCords[1] += spiralBlockSize;
              }
          }
        }
      }

      // Lines Pattern
      const linesDurationMs = 3000;
      const linesStartHoldMs = 350;
      const linesEndHoldMs = 350;

      let lastLinesLoop = Date.now();
      let curLinesRow = 0;
      let curLinesCol = 0;
      let randomRows = [];
      let randomCols = [];

      function lines(reset) {
        if (reset) {
          curLinesRow = 0;
          curLinesCol = 0;

          randomRows = shuffle([...Array(cover.height).keys()]);
          randomCols = shuffle([...Array(cover.width).keys()]);

          resetForTransform();
          lastLinesLoop = Date.now();

          return;
        }

        const now = Date.now();
        if (
          now - lastLinesLoop >
          linesDurationMs + linesEndHoldMs + linesStartHoldMs
        ) {
          curLinesRow = 0;
          curLinesCol = 0;

          randomRows = shuffle([...Array(cover.height).keys()]);
          randomCols = shuffle([...Array(cover.width).keys()]);

          randomizeColors();
          resetForTransform();

          lastLinesLoop = Date.now();
          return;
        }

        const ratio = easing(
          Math.max(now - lastLinesLoop - linesStartHoldMs, 0) / linesDurationMs
        );

        const newRow = Math.min(Math.round(ratio * cover.height), cover.height);
        for (; curLinesRow < newRow; curLinesRow++) {
          const randomRow = randomRows[curLinesRow];
          coverCtx.clearRect(0, randomRow, cover.width, 1);
        }

        const newCol = Math.min(Math.round(ratio * cover.width), cover.width);
        for (; curLinesCol < newCol; curLinesCol++) {
          const randomCol = randomCols[curLinesCol];
          coverCtx.clearRect(randomCol, 0, 1, cover.height);
        }
      }

      // Dissolve Pattern
      const dissolveDurationMs = 3000;
      const dissolveStartHoldMs = 350;
      const dissolveEndHoldMs = 350;

      let lastDissolveLoop = Date.now();
      let curDissolvePixel = 0;
      let randomIdxs = [];

      function dissolve(reset) {
        if (reset) {
          curDissolvePixel = 0;
          randomIdxs = shuffle([...Array(pixelCnt).keys()]);

          resetForTransform();
          lastDissolveLoop = Date.now();

          return;
        }

        const now = Date.now();
        if (
          now - lastDissolveLoop >
          dissolveDurationMs + dissolveEndHoldMs + dissolveStartHoldMs
        ) {
          curDissolvePixel = 0;
          randomIdxs = shuffle([...Array(pixelCnt).keys()]);

          randomizeColors();
          resetForTransform();

          lastDissolveLoop = Date.now();
          return;
        }

        const ratio = easing(
          Math.max(now - lastDissolveLoop - dissolveStartHoldMs, 0) /
            dissolveDurationMs
        );

        const newPixel = Math.min(Math.round(ratio * pixelCnt), pixelCnt);
        for (; curDissolvePixel < newPixel; curDissolvePixel++) {
          const randomIdx = randomIdxs[curDissolvePixel];
          const y = Math.floor(randomIdx / cover.width);
          const x = randomIdx % cover.width;
          coverCtx.clearRect(x, y, 1, 1);
        }
      }

      // Scanner Pattern
      const scanDurationMs = 2500;
      const scanEndHoldMs = 350;

      let horizontal = true;
      let lastScanLoop = Date.now();
      let curScanPixel = 0;

      function scanner(reset) {
        if (reset) {
          curScanPixel = 0;
          resetForTransform();

          lastScanLoop = Date.now();
          return;
        }

        const now = Date.now();
        if (now - lastScanLoop > scanDurationMs + scanEndHoldMs) {
          horizontal = !horizontal;
          curScanPixel = 0;

          randomizeColors();
          resetForTransform();

          lastScanLoop = Date.now();
          return;
        }

        const ratio = easing((now - lastScanLoop) / scanDurationMs);
        const newPixel = Math.min(Math.round(ratio * pixelCnt), pixelCnt);

        for (; curScanPixel < newPixel; curScanPixel++) {
          const y = horizontal
            ? Math.floor(curScanPixel / cover.width)
            : curScanPixel % cover.height;

          const x = horizontal
            ? curScanPixel % cover.width
            : Math.floor(curScanPixel / cover.height);

          coverCtx.clearRect(x, y, 1, 1);
        }
      }

      // Simple pattern

      let lastSimpleLoop = Date.now();
      function simple(reset) {
        const colorChangeMs = 1000;
        if (reset) {
          coverCtx.clearRect(0, 0, cover.width, cover.height);
          drawMessage(mainCtx);
          lastSimpleLoop = Date.now();
          return;
        }

        if (Date.now() - lastSimpleLoop > colorChangeMs) {
          randomizeColors();
          drawMessage(mainCtx);
          lastSimpleLoop = Date.now();
        }
      }

      /**
       * @param {CanvasRenderingContext2D} ctx
       */
      function drawMessage(ctx) {
        ctx.fillStyle = bgColor;
        ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);

        const midX = ctx.canvas.width / 2;
        const midY = ctx.canvas.height / 2;

        const fontSize = Math.min(
          Math.round(ctx.canvas.width / (maxWidth * 1.05)),
          Math.round(ctx.canvas.height / 2.7)
        );

        ctx.fillStyle = fgColor;
        ctx.textAlign = 'center';
        ctx.font = `${fontSize}px Roboto`;
        ctx.textBaseline = 'middle';

        ctx.fillText('HAPPY', midX, midY * 1.05 - fontSize / 1.15);
        ctx.fillText('BIRTHDAY', midX, midY * 1.05);
        ctx.fillText(`${nameTxt}!`, midX, midY * 1.05 + fontSize / 1.15);
      }

      function resetForTransform() {
        coverCtx.fillStyle = 'black';
        coverCtx.fillRect(0, 0, cover.width, cover.height);
        drawMessage(mainCtx);
      }

      function resize() {
        let resized = false;
        if (main.height !== window.innerHeight) {
          resized = true;
          main.height = window.innerHeight;
        }

        if (main.width !== window.innerWidth) {
          resized = true;
          main.width = window.innerWidth;
        }

        if (cover.height !== window.innerHeight) {
          resized = true;
          cover.height = window.innerHeight;
        }

        if (cover.width !== window.innerWidth) {
          resized = true;
          cover.width = window.innerWidth;
        }

        if (resized) {
          pixelCnt = window.innerHeight * window.innerWidth;
        }

        return resized;
      }

      function randomizeColors() {
        fgColor = Color(getRandomColor()).saturate(100).lightness(50);
        bgColor = fgColor.rotate(180);
      }

      function getRandomColor() {
        const letters = '0123456789ABCDEF';
        let color = '#';

        for (var i = 0; i < 6; i++) {
          color += letters[Math.floor(Math.random() * 16)];
        }

        return color;
      }

      function shuffle(array) {
        let currentIndex = array.length;

        // While there remain elements to shuffle...
        while (currentIndex != 0) {
          // Pick a remaining element...
          let randomIndex = Math.floor(Math.random() * currentIndex);
          currentIndex--;

          // And swap it with the current element.
          [array[currentIndex], array[randomIndex]] = [
            array[randomIndex],
            array[currentIndex],
          ];
        }

        return array;
      }
    </script>
  </body>
</html>
